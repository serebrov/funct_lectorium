[11:40] Эффективность рекурсивных функций
-----------------------------

Число Фиббоначи:

    f1 = f2 = 1
    fn = fn-1 + fn-2   при n > 2

Вычисление числа Фибоначчи, заданного порядковым номером:

    fib     :: Integer -> Integer
    fib 1   = 1
    fib 2   = 1
    fib n   = fib (n-1) + fib (n-2)

Неэффективность - много вычислений из-за рекурсии вычисления одних и тех же значений много раз:

    fib 6
    fib 5 + fib 4
    (fib 4 + fib 3) + fib 4

Видно, что fib 4 уже вычисляется два раза.

Можно использовать доп. аргументы:

    fib    :: Integer -> Integer
    fib'   :: Integer -> Integer -> Integer -> Integer
    fib'   n k fk fk1 | k == n = fk
                      | k < n  = fib' n (k+1) (fk+fk1) fk
    fib 1 = 1
    fib n = fib' n 2 1 1

    fib 6
    fib' 6 2 1 1
    fib' 6 3 2 1
    fib' 6 4 3 2
    fib' 6 5 5 3
    fib' 6 6 8 5
    8

Другой пример:

    factorial   :: Integer -> Integer
    factorial   0 = 1
    factorial   n = n * factorial (n-1)

Такое решение требует большого кол-ва памяти, т.к. сначала мы спускаемся по рекурсии, при этом все вычисленные значения сохраняются в стеке, и уже после возврата последней функции значения перемножаются.

Решение с доп. аргументом:                                         ы

    factorial   :: Integer -> Integer
    factorial'  :: Integer -> Integer -> Integer
    factorial n = factorial' n 1      -- (factorial' n f) == (f * n!)
    factorial' n f | n == 0 = f
                   | n >  0 = factorial' (n-1) (n*f)

В доп. аргументе получается текущее значение факториала, которое каждый раз домножается на n-1:
    4 1
    3 1*4
    2 1*4*3
    1 1*4*3*2
    0 1*4*3*2*1

Т.е. мы сразу вычисляем текущее значение факториала и уже потом спускаемся в рекурсивный вызов - т.е. не нужно сохранять в стеке все множители факториала - это позволяет компилятору сделать оптимизацию концевой рекурсии - рекурсия, при которой рекурсивный вызов - это последняя операция (в первом примере факториала последняя операция - это умножение после рекурсивных вызовов).

[27:00] Списки в Haskell
-----------------------------

Массивов нет, есть списки (это характерно и для других функциональных языков).
Массив предполагает, что мы можем менять значения элементов массива -> нужно делать новый массив.
При использовании списка (связанная структура) - можно добавлять новые элементы в начало списка, оставляя неизменным остальную часть. Во многих случаях списки в этом смысле более эффективны, чем массивы.
При добавлении элемента в конец списка - нужно перестраивать весь список. Поэтому операции с головой списка гораздо более эффективны, чем операции с хвостом.

    []          -- пустой список
    [1,2,3]     -- список из заданных элементов

Списки однородные - все элементы должны быть одного типа.

    1:[2, 3]    -- присоединение головного элемента к списку

Здесь ':' - это конструктор. Конструкторы не разрушают свои операнды - '1' присоединяется к списку [2,3] - исходные операнды остаются, создается новое значение.
[34:29]

    1:(2:(3:[])) -- создание списка с помощью конструктора ':'
