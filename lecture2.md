[11:40] Эффективность рекурсивных функций
-----------------------------

Число Фибоначчи:

    f1 = f2 = 1
    fn = fn-1 + fn-2   при n > 2

Вычисление числа Фибоначчи, заданного порядковым номером:

    fib     :: Integer -> Integer
    fib 1   = 1
    fib 2   = 1
    fib n   = fib (n-1) + fib (n-2)

Неэффективность - много вычислений из-за рекурсии вычисления одних и тех же значений много раз:

    fib 6
    fib 5 + fib 4
    (fib 4 + fib 3) + fib 4

Видно, что fib 4 уже вычисляется два раза.

[15:10] Эффективность рекурсивных функций. Концевая рекурсия.
--------------------------------------------
Можно использовать доп. аргументы:

    fib    :: Integer -> Integer
    fib'   :: Integer -> Integer -> Integer -> Integer
    fib'   n k fk fk1 | k == n = fk
                      | k < n  = fib' n (k+1) (fk+fk1) fk
    fib 1 = 1
    fib n = fib' n 2 1 1

"Лишние" аргументы играют роль переменных, которые мы могли бы использовать при решении задачи с помощью цикла.
k - номер числа Фибоначчи, вычисленного последним
fk - значение последнего числа
fk1 - значение предпоследнего числа

    fib 6
    fib' 6 2 1 1
    fib' 6 3 2 1
    fib' 6 4 3 2
    fib' 6 5 5 3
    fib' 6 6 8 5
    8

Другой пример:

    factorial   :: Integer -> Integer
    factorial   0 = 1
    factorial   n = n * factorial (n-1)

Такое решение требует большого кол-ва памяти, т.к. сначала мы спускаемся по рекурсии, при этом все вычисленные значения сохраняются в стеке, и уже после возврата последней функции значения перемножаются.

Решение с доп. аргументом:                                         ы

    factorial   :: Integer -> Integer
    factorial'  :: Integer -> Integer -> Integer
    factorial n = factorial' n 1      -- (factorial' n f) == (f * n!)
    factorial' n f | n == 0 = f
                   | n >  0 = factorial' (n-1) (n*f)

В доп. аргументе получается текущее значение факториала, которое каждый раз домножается на n-1:
    4 1
    3 1*4
    2 1*4*3
    1 1*4*3*2
    0 1*4*3*2*1

Т.е. мы сразу вычисляем текущее значение факториала и уже потом спускаемся в рекурсивный вызов - т.е. не нужно сохранять в стеке все множители факториала.
Это позволяет компилятору сделать оптимизацию концевой рекурсии - рекурсия, при которой рекурсивный вызов - это последняя операция (в первом примере факториала последняя операция - это умножение после рекурсивных вызовов).

[27:00] Списки в Haskell
-----------------------------

Массивов нет, есть списки (это характерно и для других функциональных языков).
Массив предполагает, что мы можем менять значения элементов массива -> нужно делать новый массив.
При использовании списка (связанная структура) - можно добавлять новые элементы в начало списка, оставляя неизменным остальную часть. Во многих случаях списки в этом смысле более эффективны, чем массивы.
При добавлении элемента в конец списка - нужно перестраивать весь список. Поэтому операции с головой списка гораздо более эффективны, чем операции с хвостом.

Почему добавление элемента в начало списка не вызывает его перестроение, а в конец - вызывает?

    ()->()->()->()->()
    /
   s

s - указывает на начало списка, каждый элемент указывает на следующий.
Добавляем элемент в начало:

     ()->()->()->()->()->()
     /   /
    s1  s

Теперь мы имеем список s1, включающий в себя s. При этом s не изменился.
Предположим, что мы аналогично добавляем элемент в конец:

     ()->()->()->()->()->()
     /                   /
    s, s1            new element

При этом мы получим s1 с новым элементом в конце, однако и исходный s тоже изменился.
Поэтому при добавлении в конец исходный список копируется:

    ()->()->()->()->()
    /
   s

    ()->()->()->()->()->()
    /                   /
   s1               new element

Синтаксис списков:

    []          -- пустой список
    [1,2,3]     -- список из заданных элементов

Списки однородные - все элементы должны быть одного типа.

    1:[2, 3]    -- присоединение головного элемента к списку

Здесь ':' - это конструктор. Конструкторы не разрушают свои операнды - '1' присоединяется к списку [2,3] - исходные операнды остаются, создается новое значение.

[34:29]

    1:(2:(3:[])) -- создание списка с помощью конструктора ':'
    1:2:3:[]     -- то же, что и выше, конструктор списка ':' - это
                    правоассоциативная операция,
                    поэтому скобки не нужны - выражение выполняется
                    справа налево
    [1..n]       -- создание списка с помощью арифметической прогрессии
    [2, 4..20]   -- арифм. прогрессия с заданной разностью, шаг задается
                    первыми двумя членами 2,4, т.е. мы указываем первые
                    два члена и последний

[38:00] Типы списков
-----------------------------

    [Integer]    -- список из целых чисел: [1..10]
    [Char]       -- список из символов (строка "List" == ['L','i','s','t'])
    [(Char, Int)] -- список из кортежей: [('L',1),('i',2)]
    [[Int]]       -- список из списков: [[1,2],[3,5..10],[]]

[40:40] Функция суммирования элементов списка
-----------------------------

    sumList       :: [Integer] -> Integer
    sumList []    =  0
    sumList (x:s) = x + sumList s

    sumList [1, 3, 6]
    1 + sumList [3, 6]
    1 + 3 + sumList [6]
    1 + 3 + 6 + sumList []
    1 + 3 + 6 + 0
    10

В качестве образца может использоваться константа, либо переменная, либо выражение, составленное из образцов с помощью конструктора.

(x:s) означает, что у списка есть голова и хвост (хвост может быть пустым списком).
Возможен также образец вида [x,y,z] (то же, что и (x:y:z:[])). Этот образец сопоставляется со списком из ровно трех элементов.
Образец (x:y:z:[s]) будет сопоставлен со списком из трех или более элементов.

Стандартная функция для суммирования - sum.

[50:00] Факториал - еще один способ (со списком)
--------------------------------------------

    factorial       :: Integer -> Integer
    factorial n     :: product [1..n]

Здесь product - функция для перемножения списка чисел.
Т.е. функция составляет список из n элементов и затем перемножает их.

[53:00] Стандартные операции над списками
--------------------------------------------
Операции ниже - встроенные, описаны для наглядности.
В описании функций ниже используются переменные типа - [a] - список из элементов любого типа (напр. head :: [a] -> a)

Получить голову списка:

    head        :: [a] -> a
    head (x:ls) = x
    head []     = error "head: empty list"

Получить хвост списка:

    tail        :: [a] -> [a]
    tail (x:ls) = ls
    tail []     = error "tail: empty list"

Длина:

    length        :: [a] -> Int
    length (x:ls) = 1 + length ls
    length []     = 0

Проверка на пустоту:

    null        :: [a] -> Bool
    null (x:ls) = False
    null []     = True

Последний элемент:

    last        :: [a] -> a
    last []     = error "last: empty list"
    last [x]    = x
    last (x:ls) = last ls

Список без последнего элемента:

    init        :: [a] -> [a]
    init []     = error "init: empty list"
    init [x]    = []
    init (x:ls) = x : init ls

Элемент списка по номеру:

    (!!)        :: [a] -> Int -> a
    [] !! _     = error "(!!): empty list"
    (x:ls) !! 0 = x
    (x:ls) !! n = ls !! (n-1)

Здесь описывается инфиксная бинарная операция.
Знак операции в описании типа заключается в скобки.
Инфиксная запись:  [] !! _
Префиксная запись: (!!) [] _

Знак подчеркивания _ - это специальная "безымянная" переменная, которая используется только в определении, но не в правой части.

Объединение списков:

    (++)        :: [a] -> [a] -> [a]
    [] ++ ls    :: ls
    (x:l1) ++ l2:: x : (l1 ++ l2)

С ее помощью можно также добавить новый элемент в конец списка.

[0:00] Часть 2
--------------------------------------------

Перевернуть список:

    reverse             :: [a] -> [a]
    reverse'            :: [a] -> [a] -> [a]
    reverse ls          = reverse' ls []
    reverse' [] l       = l
    reverse' (x:ls) l   = reverse' ls (x:l)

Сумма элементов:

    sum                 :: Num a => [a] -> a
    sum []              = 0
    sum (x:t)           = x + sum t


Num a - определяет класс типа (числовое значение), классы типов подобны интерфейсам в ООП.

Получить определенное количество первых элементов списка:

    take                :: Int -> [a] -> [a]
    take _ []           = []
    take n _ | n <=0    = []
    take n (x:t)        = x : take (n-1) t

Для пустого списка возвращает пустой список.
Если n <=0 возвращает пустой список, независимо от переданного списка.

Максимальное значение:

    maximum             :: Ord a => [a] -> a
    maximum []          = error "maximum: empty list"
    maximum [x]         = x
    maximum (x:t)       = max x (maximum t)

Ord - класс упорядочиваемых элементов.
max - функция, возвращающая большее из двух значений.

Из двух списков составляет список пар значений:

    zip             :: [a] -> [b] -> [(a, b)]
    zip [] _        :: []
    zip _ []        :: []
    zip (e1:t1) (e2:t2) = (e1, e2) : zip t1 t2

zip3 - из трех списков составляет тройки значений
fst - возвращает первое значение кортежа
snd - возвращает второе значение кортежа

Преобразует список из пар в пару списков:

    unzip           :: [(a,b)] -> ([a],[b])
    unzip []        = ([],[])
    unzip ((e1,e2):t)   = (e1:tail1, e2:tail2) where (tail1, tail2) = unzip t

[0:11:10] Определение новых типов данных
--------------------------------------------

Определение синонимов:
--------------------------------------------

    type String     = [Char]
    type Coord      = (Double, Double)
    type Pair a     = (a, a)
    type Complex    = Pair Double

String - уже определен в стандартной библиотеке.
Pair - синоним с параметром - кортеж из двух любых элементов одного и того же типа 'a'.

Найти элемент и вернуть его индекс

    find                     :: String -> Char -> Int
    find [] _                = -1
    find (x:s) y | x == y    = 0
                 | otherwise = 1 + find s y

Используется String.
Функция задумывалась как возвращающая -1, если элемент не найден, но на самом деле она вернет длину строки -1 (длина строки накопится при рекурсивных вызовах в последней ветке otherwise)

В примере определения синонимов выше Coord и Complex на самом деле представляют собой один и тот же тип - пара из Double.
Они будут взаимозаменяемы, что не всегда хорошо.

    distance        :: Coord -> Coord -> Double
    distance (x1, y1) (x2, y2) = sqrt ((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1))

    complexAdd      :: Complex -> Compex -> Complex
    complexAdd (r1, i1) (r2, i2) = (r1+r2, i1+i2)

При текущем определении типов можно перепутать и передать координату в complexAdd или комплексное число в distance.

Переставить значения в паре из элементов одного (любого) типа:

    swap        :: Pair a -> Pair a
    swap (w, y) :: (y, x)

[0:21:20] Новые типы данных
--------------------------------------------

### Определение конструкторов.
Конструктор - способ образования значений для типа данных.

Имена новых типов данных (и синонимов) должны начинаться с заглавной буквы.

    data WeekDay = Sun | Mon | Tue | Wed | Thu | Fri | Sat
    data Bool    = False | True

Здесь Sun, Mon, ... - конструкторы.
Bool - для примера, стандартный тип.

### Использование конструкторов:

    weekend         :: WeekDay -> Bool
    weekend Sun     = True
    weekend Sat     = True
    weekend _       = False

По сути Sun, Sat здесь являются константами-конструкторами и, в принципе, любая константа является конструктором (25 конструирует целое число).
По сути конструкторы для типа данных являются перечислением и внутри будут иметь значения 0, 1, 2 ...
Имена конструкторов должны быть уникальными - например, нельзя использовать Sun в определении двух типов данных.

* Нельзя перегружать функции, но можно написать полиморфную функцию, без четкого задания типов аргументов.
* Нельзя написать функцию с переменным числом параметров, но можно написать функцию, принимающую список.
* Перегрузки операций нет, но можно определить класс типов и написать общие операции для нескольких типов

### Конструкторы с параметром

    data Coord  = Point Double Double
    data Pair a = Couple a a

Coord - тип данных с конструктором Point, у конструктора два пaраметра типа Double.
Pair - тип данных с конструктором Couple, тип данных параметризован параметром a, конструктор принимает два значения типа a (одинаковый любой тип).

Использование:

    distance :: Coord -> Coord -> Double
    distance (Point x1 y1) (Point x2 y2) = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1))

Конструктор не изменяет своих параметров, он только собирает их в единое целое. Это единое целое затем можно разобрать обратно в образцах.

    swap        :: Pair a -> Pair a
    swap (Couple x y) = Couple y x

Можно использовать имена типов в качестве имен конструкторов:

    data Coord      = Coord Double Double

    distance (Coord x1 y1) (Coord x2 y2) = sqrt(...)

### Сложные типы данных

Список из целых:

    data IntList = Nil | Cons Integer IntList

Два конструктора - пустой список и Cons, принимающий новую голову и список-хвост.
Суммирование элементов:

    sumList             :: IntList -> Integer
    sumList Nil         = 0
    sumList (Cons e ls) = e + sumList ls

С бинарным конструктором и любым типом:

    data List a = Nil | a :+: (List a)

Бинарный конструктор должен начинаться с двоеточия (:).

    sumList             :: List Integer -> Integer
    sumList Nil         = 0
    sumList (e :+: ls) = e + sumList ls

Oбобщение функции (любой тип класса Num - над элементами можно выполнять арифметические операции):

    sumList             :: (Num a) => List a -> a
    sumList Nil         = 0
    sumList (e :+: ls) = e + sumList ls

Создание списка:

    1 :+: (2 :+: (3 :+: Nil))

Скобки нужны, так как по-умолчанию созданный конструктор является левоассоциативной операцией.
Т.е. 1 :+: 2 :+: 3 :+: Nil будет выполняться слева направо и передавать в конструктор два целых числа вместо числа и списка.

Определение стандартного списка могло бы выглядеть примерно так:

    data [a] = [] | a : [a]

    sumList             :: (Num a) => [a] -> a
    sumList []          = 0
    sumList (e : ls)    = e + sumList ls

[] - пустой список
:  - бинарный конструктор с двумя параметрами типа a и список из элементов типа a.

### [0:52:20] Сортировка списка

Функция вставляет элемент на свое место в отсортированный по возрастанию список.
    insert          :: (Ord a) => a -> [a] -> [a]
    insert elem []  = [elem]
    insert elem list@(x:s) | elem < x   = elem:list
                           | otherwise  = x:(insert elem s)

list@ - задает имя всего образца (списка).
Можно задавать имя для всего образца или любой его части.

    bubble          :: (Ord a) => [a] -> [a]
    bubble []       = []
    bubble (x:s)    = insert x (bubble s)

Вариант, принимающий функцию сравнения в качестве параметра:

    insert                  :: (a -> a -> Bool) -> a -> [a] -> [a]
    insert _ elem []        = [elem]
    insert f elem list@(x:s) | f elem x = elem:list
                             | otherwise = x:(insert f elem s)

### [1:04:00] Определение и обработка двоичного дерева

         (A)
        /   \
       (B)  (C)
       /    /  \
      (D)  (E) (F)

    data Tree a = Empty |
                  Node (Tree a) a (Tree a)

Empty - пустое дерево
Node - узел: левое под-дерево - корень - правое под-дерево

    myTree :: Tree Char
    myTree = Node (Node
                    (Node Empty 'D' Empty)
                    'B'
                    Empty)
                  'A'
                  (Node
                    (Node Empty 'E' Empty)
                    'C'
                    (Node Empty 'F' Empty))

Вычисление высоты дерева:

    height :: Tree a -> Int
    height Empty          = 0
    height (Node t1 _ t2) = 1 + max (height t1) (height t2)

### Сортировка с помощью двоичного дерева.

Из списка строим дерево.
Берем последний элемент, добавляем в корень, берем следующий, если он меньше - то налево, если больше, то направо:

    [9]                    (4)                        [1]
    [2]                   /   \                       [2]
    [6] -> build ->    (1)    (8)      -> flatten ->  [4]
    [1]                 \     /  \                    [6]
    [8]                 (2) (6)  (9)                  [8]
    [4]                                               [9]

Потом из дерева строим упорядоченный список - проходим узлы слева направо (в порядке возрастания).

    sort        :: (Ord a) => [a] -> [a]
    build       :: (Ord a) => [a] -> Tree a
    insert      :: (Ord a) => a -> Tree a -> Tree a
    flattern    :: Tree a -> [a]

    sort ls     = flattern (build ls)

    build []     = Empty
    build (e:ls) = insert e (build ls)

    insert e Empty                    = Node Empty e Empty
    insert e (Node t1 n t2) | e < n   = Node (insert e t1) n t2
                            | e >= n  = Node t1 n (insert e t2)

    flattern Empty      = []
    flattern (Node t1 n t2) = (flattern t1) ++ (n:(flattern t2))

Функция flattern неэффективна, т.к. операция ++ выполняется не за постоянное время - правый аргумент "разбирается" и потом собирается назад.
Вся сортировка из-за этого становится квадратичной (вместо n*log n).
Сделать flattern лучше можно, введя дополнительный параметр для сохранения промежуточных результатов.

[1:21:40 ] Средства функционального программирования
--------------------------------------------

### Функции высших порядков

Функции высших порядков принимают в качестве аргументов или возвращают функции.

    sqr     :: Integer -> Integer
    sqr x   = x * x

    source = [1, 2, 5]
    sqr
    dest   = [1, 4, 25]
    dest   = map sqr source

    map         :: (Integer -> Integer) -> [Integer] -> [Integer]
    map _ []    = []
    map f (x:s) = (f x):(map f s)

map есть в стандартной библиотеке.
Более общее определение:

    map         :: (a -> b) -> [a] -> [b]
    map _ []    = []
    map f (x:s) = (f x):(map f s)

### Определение функций с помощью l-выражений

l-исчисление Черча - исчисление безымянных функций.

Определение лямбда-выражением:

    sqr : lx. * x x

          [лямбда переменная точка тело]
          тело - умножение в инфиксной записи

На Haskell вместо лямбды используется '\':

    sqr = \x -> (x * x)

Т.е. можно определять функции с помощью уравнений (как ранее) либо с помощью лямбда-выражений.

### Факториал с помощью лямбда-выражения

    factoial :: Integer -> Integer
    factorial = \n -> case n of
                        0 -> 1
                        n -> n * factorial (n-1)



